name: create release
'on':
  push:
    paths-ignore: '**/README.md'
jobs:
  release-project:
    name: Update the catalog
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v2
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v2
      with:
        python-version: ${{ matrix.python-version }}
    - name: Install dependencies
      run: 'python -m pip install --upgrade pip
        pip install regex PyYAML python-csv requests PyGithub 
        '
    - name: Update catalog
      env:
        SECRET: ${{ secrets.SECRET_TOKEN }}
      run: |
        import re
        import os
        import requests
        import json
        import yaml
        import logging
        import csv
        from github import Github
        from pathlib import Path

        logging.basicConfig(
            filename="catalog_info.log",
            format="%(levelname)s: %(message)s",
            level=logging.INFO
        )

        def notifier(msg):
            logging.info(msg)

        def commit(repo, message, not_includes=[], branch="main"):
            has_changed = False

            for fn in repo.untracked_files:
                ignored = False
                for not_include_fn in not_includes:
                    if not_include_fn in fn:
                        ignored = True
                if ignored:
                    continue
                if fn:
                    repo.git.add(fn)
                if has_changed is False:
                    has_changed = True

            if repo.is_dirty() is True:
                for fn in repo.git.diff(None, name_only=True).split("\n"):
                    if fn:
                        repo.git.add(fn)
                    if has_changed is False:
                        has_changed = True
                if has_changed is True:
                    if not message:
                        message = "Initial commit"
                    repo.git.commit("-m", message)
                    repo.git.push("origin", branch)
                    print(f"{pecha_id} pagination updated")

        def setup_auth(repo, org, token):
            remote_url = repo.remote().url
            old_url = remote_url.split("//")
            authed_remote_url = f"{old_url[0]}//{org}:{token}@{old_url[1]}"
            repo.remote().set_url(authed_remote_url)

        def get_title_and_work_id(g, pecha_id):
            try:
                repo = g.get_repo(f"Openpecha/{pecha_id}")
                contents = repo.get_contents(f"{pecha_id}.opf/meta.yml")
                meta_content = contents.decoded_content.decode()
                metadata = yaml.safe_load(meta_content)
                work_id = metadata['source_metadata']['id'][4:]
                title = metadata['source_metadata']['title']
            except:
                work_id = None
                title = None
            return title, work_id

        def remove_nonexisted_repos_from_catalog(temp_catlog_path, pecha_ids):
            for pecha_id in pecha_ids:
                if pecha_id == "P000001":
                    continue
                elif pecha_id == "P000002":
                    continue
                title, work_id = get_title_and_work_id(g, pecha_id)
                if title == None:
                    if work_id == None:
                        row_string = f"[{pecha_id}](https://github.com/OpenPecha/{pecha_id}),,,,\n"
                    else:
                        row_string = f"[{pecha_id}](https://github.com/OpenPecha/{pecha_id}),,,,bdr:{work_id}\n"
                else:
                    row_string = f"[{pecha_id}](https://github.com/OpenPecha/{pecha_id}),{title},,,bdr:{work_id}\n"
                print(row_string)
                with open(f"{repo_path}/catalog.csv", "a", encoding='utf-8') as csvfile:
                    csvfile.write(row_string)
                

        def check_catalog_for_repo(catalog_path, pecha_id):
            num = 0
            with open(f"{catalog_path}/{catalog.csv}", newline="") as file:
                pechas = list(csv.reader(file, delimiter=","))
                for pecha in pechas[3:]:
                    res = not bool(pecha)
                    if res == False:
                        pecha_id_csv = re.search("\[.+\]", pecha[0])[0][1:-1]
                        if pecha_id == pecha_id_csv:
                            num += 1
                            print(f"{pecha_id} is available")
                            break
                if num == 0:
                    notifier(f"{pecha_id} is not in catalog")
                    print(f"{pecha_id} is not in catalog")
                    return pecha_id
            return None

        def check_repo_names_in_catalog(g, repo_names):
            add_to_catalog = []
            for num in sorted(repo_names):
                pecha_id = repo_names[num]['repo']
                pecha_ids = check_catalog_for_repo(catalog_path, pecha_id)
                if pecha_ids != None:
                    add_to_catalog.append(pecha_ids)
            return add_to_catalog

        def check_repo_in_github(g, string):
            pecha = re.search(r"\((.*?)\)", string)
            pechaurl = pecha.group(1)
            pecha_id = pechaurl[29:]
            try:
                repo = g.get_repo(f"ta4tsering/{pecha_id}")
                return None
            except:
                print(f"this pecha {pecha_id} has no repository")
                notifier(f"this pecha {pecha_id} has no repository")
                return pecha_id
                
        def get_rows(g,catalog):
            rows = []
            strings = re.split(r"[\r\n]",catalog)
            for num, string in enumerate(strings, 0):
                if num == 0:
                    rows.append(string)
                elif num%2 == 0:
                    if len(string) != 0:
                        change = check_repo_in_github(g, string)
                        if change == None:
                            rows.append(string)
            return rows

        def get_catalog_from_github(g, cataglog_path):
            repo = g.get_repo(f"ta4tsering/catalog")
            content = repo.get_contents(f"data/catalog.csv")
            catalog = content.decoded_content.decode()
            rows = get_rows(g,catalog)
            with open(f"{catalog_path}/catalog.csv", "w", encoding='utf-8') as f:
                for row in rows:
                    f.write(row)
                    f.write(f"\n")

        def get_repo_names(headers):
            repo_names = {}
            curr_name = {}
            new_name = 30000
            nums = 1
            response = requests.get(f"https://api.github.com/users/ta4tsering/repos?per_page=100", headers=headers)
            data = response.json()
            for info in data:
                repo_name = info["name"]
                if len(repo_name) == 32:
                    new_name += nums
                    name = new_name
                elif re.search(r"[catalog|hfml|users|ebook-template|nalanda-notes|diplomatic-kanjur]", repo_name):
                    continue
                elif len(repo_name) <= 7 :
                    name = repo_name[1:]
                    name = int(name)
                curr_name[name]={'repo':repo_name}
                repo_names.update(curr_name)
                curr_name = {}
            return repo_names

        def download_pecha(pecha_id, out_path=None, branch="master"):
            pecha_url = f"{config['OP_ORG']}/{pecha_id}.git"
            out_path = Path(out_path)
            out_path.mkdir(exist_ok=True, parents=True)
            pecha_path = out_path / pecha_id
            Repo.clone_from(pecha_url, str(pecha_path))
            repo = Repo(str(pecha_path))
            branch_to_pull = get_branch(repo, branch)
            repo.git.checkout(branch_to_pull)
            print(f"{pecha_id} Downloaded ")
            return pecha_path        

        if __name__ == '__main__':
            token = os.environ.get('SECRET')
            g = Github(token)
            commit_msg = "updated catalog"
            headers = {"Authorization": f"bearer {token}"}
            file_path = './'
            repo_path = download_repo(catalog_repo, file_path)
            repo_names = get_repo_names(headers)
            get_catalog_from_github(g, catalog_path)
            pecha_ids = check_repo_names_in_catalog(g, repo_names)
            remove_nonexisted_repos_from_catalog(pecha_ids)
            repo = Repo(pecha_path)
            setup_auth(repo, "ta4tsering", token)
            commit(repo, commit_msg, branch="main")
      shell: python
